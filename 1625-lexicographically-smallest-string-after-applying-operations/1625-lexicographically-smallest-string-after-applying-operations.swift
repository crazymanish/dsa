class Solution {
    /**
     * Finds the lexicographically smallest string obtainable by applying two operations:
     * 1. Add Operation: Add `a` to all digits at odd indices (0-indexed), with the result taken modulo 10.
     * 2. Rotate Operation: Shift the string to the left by `b` positions (e.g., "12345" with b=2 becomes "34512").
     *
     * The solution explores all possible strings that can be generated from the starting
     * string `s`. It treats the problem as a graph traversal, where each unique string
     * configuration is a node.
     *
     * A Depth-First Search (DFS) is used to visit every reachable node. A `Set` is used
     * to keep track of visited states to avoid infinite loops and redundant computations.
     * During the traversal, the function continually updates a variable to store the
     * lexicographically smallest string found so far.
     */
    func findLexSmallestString(_ s: String, _ a: Int, _ b: Int) -> String {

        // A set to store all unique string states we've visited to prevent cycles.
        // Storing the string as an array of integers makes the arithmetic for the "add" operation easier.
        var visitedStates = Set<[Int]>()
        
        // This variable will be updated throughout the search to hold the best result found.
        var lexicographicallySmallestString = s

        // This is the main recursive function that performs the Depth-First Search.
        // It explores all states reachable from the `currentStateAsIntArray`.
        func dfs(_ currentStateAsIntArray: [Int]) {

            // Base case for the recursion: If we have already processed this state, stop exploring this path.
            guard !visitedStates.contains(currentStateAsIntArray) else { return }
            
            // Mark the current state as visited so we don't process it again.
            visitedStates.insert(currentStateAsIntArray)

            // This variable will be modified by the "add" operation in the loop below.
            // It starts as the current state and is transformed on each iteration.
            var stateAfterAdditions = currentStateAsIntArray
            
            // This array will store all states generated by the "rotate" operation.
            // These will be the next states to explore in our DFS traversal.
            var rotatedStatesToExplore = [[Int]]()

            // This loop generates all possible strings reachable from `currentStateAsIntArray`
            // by repeatedly applying the "add" operation. For each of these generated strings,
            // we perform one "rotate" operation and queue it up for the next DFS calls.
            repeat {
                // Convert the current integer array back to a string for comparison.
                let currentString = stateAfterAdditions.map { "\($0)" }.joined()
                
                // Update the overall smallest string found so far.
                lexicographicallySmallestString = min(lexicographicallySmallestString, currentString)
                
                // Perform the "rotate" operation: move the last `b` characters to the front.
                let rotatedState = Array(stateAfterAdditions.suffix(b) + stateAfterAdditions.prefix(s.count - b))
                rotatedStatesToExplore.append(rotatedState)
                
                // Perform the "add" operation: add `a` to all digits at odd indices.
                for i in stride(from: 1, to: stateAfterAdditions.count, by: 2) {
                    stateAfterAdditions[i] = (stateAfterAdditions[i] + a) % 10
                }
                
            // The "add" operation is cyclic. The loop terminates when it cycles back to the state it started with.
            } while stateAfterAdditions != currentStateAsIntArray

            // After exploring all "add" transformations, recursively call DFS for all the
            // new states we generated via the "rotate" operation.
            for nextState in rotatedStatesToExplore {
                dfs(nextState)
            }
        }

        // To begin the process, convert the initial string into an array of integers.
        let initialStringAsIntArray = s.map { Int(String($0))! }
        
        // Start the DFS from the initial state.
        dfs(initialStringAsIntArray)

        return lexicographicallySmallestString
    }
}