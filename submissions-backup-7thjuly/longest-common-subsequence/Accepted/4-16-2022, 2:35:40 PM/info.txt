{"id":681433943,"lang":"swift","time":"2 months, 3 weeks","timestamp":1650112540,"status_display":"Accepted","runtime":"22 ms","url":"/submissions/detail/681433943/","is_pending":"Not Pending","title":"Longest Common Subsequence","memory":"21.9 MB","code":"// Using Dynamic programming with Top-down matrix\nclass Solution {\n    func longestCommonSubsequence(_ text1: String, _ text2: String) -> Int {\n        let rows = Array(text1)\n        let columns = Array(text2)\n        \n        let rowsCount = rows.count\n        let columnsCount = columns.count\n        \n        var dpMatrix = Array(repeating: Array(repeating: 0, count: columnsCount+1), count: rowsCount+1)\n        \n        for rowIndex in 1...rowsCount {\n            let currentRowChar = rows[rowIndex-1]\n            for columnIndex in 1...columnsCount {\n                let currentColumnChar = columns[columnIndex-1]\n                \n                if currentRowChar == currentColumnChar {\n                    let previousLCS = dpMatrix[rowIndex-1][columnIndex-1]\n                    dpMatrix[rowIndex][columnIndex] = 1 + previousLCS\n                } else {\n                    let previousRowLCS = dpMatrix[rowIndex-1][columnIndex]\n                    let previousColumnLCS = dpMatrix[rowIndex][columnIndex-1]\n                    let previousLCS = max(previousRowLCS, previousColumnLCS)\n                    \n                    dpMatrix[rowIndex][columnIndex] = previousLCS\n                }\n            }\n        }\n        \n        return dpMatrix[rowsCount][columnsCount]\n    }\n}\n\n/*\n// Using Dynamic programming with recursion + Cache\nclass Solution {\n    func longestCommonSubsequence(_ text1: String, _ text2: String) -> Int {\n        let text1Array = Array(text1)\n        let text2Array = Array(text2)\n        \n        let text1Count = text1Array.count\n        let text2Count = text2Array.count\n        \n        var dpCache = Array(repeating: Array(repeating: -1, count: text2Count+1), count: text1Count+1)\n        \n        func findLongestCommonSubsequence(_ text1Count: Int, _ text2Count: Int) -> Int {\n            if text1Count == 0 || text2Count == 0 { return 0 }\n            \n            if dpCache[text1Count][text2Count] != -1 { return dpCache[text1Count][text2Count] }\n            \n            let longestCommonSubsequence: Int\n            \n            if text1Array[text1Count-1] == text2Array[text2Count-1] {\n                longestCommonSubsequence = 1 + findLongestCommonSubsequence(text1Count-1, text2Count-1)\n            } else {\n                let text1LongestCommonSubsequence = findLongestCommonSubsequence(text1Count, text2Count-1)\n                let text2LongestCommonSubsequence = findLongestCommonSubsequence(text1Count-1, text2Count)\n                longestCommonSubsequence = max(text1LongestCommonSubsequence, text2LongestCommonSubsequence)\n            }\n            \n            dpCache[text1Count][text2Count] = longestCommonSubsequence\n            return longestCommonSubsequence\n        }\n        \n        return findLongestCommonSubsequence(text1Count, text2Count) \n    }\n}\n*/","compare_result":"111111111111111111111111111111111111111111111","title_slug":"longest-common-subsequence"}