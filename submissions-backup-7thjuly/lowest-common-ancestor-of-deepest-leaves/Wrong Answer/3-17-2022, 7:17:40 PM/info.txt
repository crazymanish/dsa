{"id":661969381,"lang":"swift","time":"3 months, 3 weeks","timestamp":1647541060,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/661969381/","is_pending":"Not Pending","title":"Lowest Common Ancestor of Deepest Leaves","memory":"N/A","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    private var depthWithLcaNodeHashMap: [Int : TreeNode] = [:]\n    private var maxDepth = Int.min\n\n    func lcaDeepestLeaves(_ root: TreeNode?) -> TreeNode? {\n        guard let root = root else { return nil }\n\n        findLcaDeepestLeaves(root, 0, root)\n\n        return depthWithLcaNodeHashMap[maxDepth]\n    }\n\n    private func findLcaDeepestLeaves(_ root: TreeNode?, _ currentDepth: Int, _ currentPathLcaNode: TreeNode) {\n        guard let currentNode = root else { return }\n\n        let newDepth = currentDepth + 1\n        maxDepth = max(maxDepth, newDepth)\n\n        var newPathLcaNode = currentPathLcaNode\n        if currentNode.val < currentPathLcaNode.val { newPathLcaNode = currentNode }\n\n        if let existingLcaNode = depthWithLcaNodeHashMap[newDepth] {\n            let minLcaNode = TreeNode.minNode(existingLcaNode, node2: newPathLcaNode)\n            depthWithLcaNodeHashMap[newDepth] = minLcaNode\n        } else {\n            depthWithLcaNodeHashMap[newDepth] = newPathLcaNode\n        }\n\n        findLcaDeepestLeaves(currentNode.left, newDepth, newPathLcaNode)\n        findLcaDeepestLeaves(currentNode.right, newDepth, newPathLcaNode)\n    }\n}\n\nprivate extension TreeNode {\n    static func minNode(_ node1: TreeNode, node2: TreeNode) -> TreeNode {\n        if node1.val < node2.val { return node1 }\n\n        return node2\n    }\n}","compare_result":"110100000000000100100000101000000000000000000100100100000000000000000000000000000","title_slug":"lowest-common-ancestor-of-deepest-leaves"}