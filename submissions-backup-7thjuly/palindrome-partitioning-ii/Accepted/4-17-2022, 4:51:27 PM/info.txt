{"id":682204615,"lang":"swift","time":"2 months, 3 weeks","timestamp":1650207087,"status_display":"Accepted","runtime":"3 ms","url":"/submissions/detail/682204615/","is_pending":"Not Pending","title":"Palindrome Partitioning II","memory":"14.4 MB","code":"class Solution {\n    func minCut(_ s: String) -> Int {\n        let sArray = Array(s)\n        let sArrayCount = sArray.count\n        \n        var dpCacheCuts = [Int](repeating: 0, count: sArrayCount + 1)\n        for i in 0...sArrayCount { dpCacheCuts[i] = i - 1 }\n        \n        var leftPointer = 0\n        var rightPointer = 0\n        while leftPointer < sArrayCount {\n            \n            // Odd length palindromes.\n            rightPointer = 0\n            while leftPointer-rightPointer >= 0 && \n                leftPointer + rightPointer < sArrayCount && \n                sArray[leftPointer-rightPointer] == sArray[leftPointer+rightPointer] {\n                dpCacheCuts[leftPointer+rightPointer+1] = min(dpCacheCuts[leftPointer+rightPointer+1], 1 + dpCacheCuts[leftPointer-rightPointer])\n                rightPointer += 1\n            }\n            \n            // Even length palindromes.\n            rightPointer = 1\n            while leftPointer-rightPointer+1 >= 0 && \n                leftPointer+rightPointer < sArrayCount && \n                sArray[leftPointer-rightPointer+1] == sArray[leftPointer+rightPointer] {\n                dpCacheCuts[leftPointer+rightPointer+1] = min(dpCacheCuts[leftPointer+rightPointer+1], 1 + dpCacheCuts[leftPointer-rightPointer+1])\n                rightPointer += 1\n            }   \n            \n            leftPointer += 1\n        }\n        \n        return dpCacheCuts[sArrayCount]\n    }\n}\n\n/*\n// Solution with MCM concept but getting TimeOut \nclass Solution {\n    // Dynamic programming - MCM concept\n    func minCut(_ s: String) -> Int {\n        let sCount = s.count\n        var dpCache = Array(repeating: Array(repeating: -1, count: sCount), count: sCount)\n        \n        func findMinCutCount(_ s: String, _ startIndex: Int, _ endIndex: Int) -> Int {\n            // check result in cache first...to avoid expensive recersive-calls\n            let cacheValue = dpCache[startIndex][endIndex] \n            if cacheValue != -1 { return cacheValue }\n            \n            if startIndex >= endIndex { return 0 } // Base case\n            if isPalindrome(s, startIndex, endIndex) { return 0 } // Found Palindrome\n            \n            // Find min cut using MCM concept\n            var minCutCount = Int.max\n            for k in startIndex..<endIndex {\n                let leftMinCutCount = findMinCutCount(s, startIndex, k)\n                let rightMinCutCount = findMinCutCount(s, k+1, endIndex)\n            \n                let currentCutCount = 1 + leftMinCutCount + rightMinCutCount    \n                minCutCount = min(minCutCount, currentCutCount)\n            }\n            \n            // Update cache\n            dpCache[startIndex][endIndex] = minCutCount\n            \n            return minCutCount\n        }\n    \n        return findMinCutCount(s, 0, sCount-1)\n    }\n    \n// Timeout because isPalindrome is not using cache\n   private func isPalindrome(_ s: String, _ leftIndex: Int, _ rightIndex: Int) -> Bool {\n        let array = Array(s)\n        var leftPointerIndex = leftIndex\n        var rightPointerIndex = rightIndex\n        \n        while leftPointerIndex <= rightPointerIndex {\n            let leftChar = array[leftPointerIndex]\n            let rightChar = array[rightPointerIndex]\n            \n            if leftChar != rightChar { return false }\n            \n            leftPointerIndex += 1\n            rightPointerIndex -= 1\n        }\n        \n        return true\n    }\n}\n*/\n","compare_result":"111111111111111111111111111111111111","title_slug":"palindrome-partitioning-ii"}