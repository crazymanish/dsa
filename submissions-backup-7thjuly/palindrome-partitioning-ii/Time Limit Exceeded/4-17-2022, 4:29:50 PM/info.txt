{"id":682194843,"lang":"swift","time":"2 months, 3 weeks","timestamp":1650205790,"status_display":"Time Limit Exceeded","runtime":"N/A","url":"/submissions/detail/682194843/","is_pending":"Not Pending","title":"Palindrome Partitioning II","memory":"N/A","code":"class Solution {\n    // Dynamic programming - MCM concept\n    func minCut(_ s: String) -> Int {\n        let sCount = s.count\n        var dpCache = Array(repeating: Array(repeating: -1, count: sCount), count: sCount)\n        var isPalindromeCache: [[Bool?]] = Array(repeating: Array(repeating: nil, count: s.count), count: s.count)\n        \n        func findMinCutCount(_ s: String, _ startIndex: Int, _ endIndex: Int) -> Int {\n            // check result in cache first...to avoid expensive recersive-calls\n            let cacheValue = dpCache[startIndex][endIndex] \n            if cacheValue != -1 { return cacheValue }\n            \n            if startIndex >= endIndex { return 0 } // Base case\n            if isPalindrome(s, startIndex, endIndex) { return 0 } // Found Palindrome\n            \n            // Find min cut using MCM concept\n            var minCutCount = Int.max\n            for k in startIndex..<endIndex {\n                let leftMinCutCount = findMinCutCount(s, startIndex, k)\n                let rightMinCutCount = findMinCutCount(s, k+1, endIndex)\n            \n                let currentCutCount = 1 + leftMinCutCount + rightMinCutCount    \n                minCutCount = min(minCutCount, currentCutCount)\n            }\n            \n            // Update cache\n            dpCache[startIndex][endIndex] = minCutCount\n            \n            return minCutCount\n        }\n        \n        func isPalindrome(_ s: String, _ startIndex: Int, _ endIndex: Int) -> Bool {\n            if isPalindromeCache[startIndex][endIndex] == nil {\n                isPalindromeCache[startIndex][endIndex] = true\n        \n                let sArray = Array(s)\n                var currentStart = startIndex\n                var currentEnd = endIndex\n        \n                while currentStart < currentEnd {\n                    if sArray[currentStart] != sArray[currentEnd] {\n                        isPalindromeCache[startIndex][endIndex] = false\n                        break\n                    }\n            \n                    currentStart += 1\n                    currentEnd -= 1\n            \n                    if currentStart < currentEnd && isPalindromeCache[currentStart][currentEnd] != nil {\n                        isPalindromeCache[startIndex][endIndex] = isPalindromeCache[currentStart][currentEnd]\n                        break\n                    }\n                }\n            }\n    \n            return isPalindromeCache[startIndex][endIndex] ?? false\n        }\n    \n        return findMinCutCount(s, 0, sCount-1)\n    }\n}\n\n/*\nclass Solution {\n    // Dynamic programming - MCM concept\n    func minCut(_ s: String) -> Int {\n        let sCount = s.count\n        var dpCache = Array(repeating: Array(repeating: -1, count: sCount), count: sCount)\n        \n        func findMinCutCount(_ s: String, _ startIndex: Int, _ endIndex: Int) -> Int {\n            // check result in cache first...to avoid expensive recersive-calls\n            let cacheValue = dpCache[startIndex][endIndex] \n            if cacheValue != -1 { return cacheValue }\n            \n            if startIndex >= endIndex { return 0 } // Base case\n            if isPalindrome(s, startIndex, endIndex) { return 0 } // Found Palindrome\n            \n            // Find min cut using MCM concept\n            var minCutCount = Int.max\n            for k in startIndex..<endIndex {\n                let leftMinCutCount = findMinCutCount(s, startIndex, k)\n                let rightMinCutCount = findMinCutCount(s, k+1, endIndex)\n            \n                let currentCutCount = 1 + leftMinCutCount + rightMinCutCount    \n                minCutCount = min(minCutCount, currentCutCount)\n            }\n            \n            // Update cache\n            dpCache[startIndex][endIndex] = minCutCount\n            \n            return minCutCount\n        }\n    \n        return findMinCutCount(s, 0, sCount-1)\n    }\n    \n// Timeout because isPalindrome is not using cache\n   private func isPalindrome(_ s: String, _ leftIndex: Int, _ rightIndex: Int) -> Bool {\n        let array = Array(s)\n        var leftPointerIndex = leftIndex\n        var rightPointerIndex = rightIndex\n        \n        while leftPointerIndex <= rightPointerIndex {\n            let leftChar = array[leftPointerIndex]\n            let rightChar = array[rightPointerIndex]\n            \n            if leftChar != rightChar { return false }\n            \n            leftPointerIndex += 1\n            rightPointerIndex -= 1\n        }\n        \n        return true\n    }\n}\n*/\n","compare_result":"111111111111111111111111111100000000","title_slug":"palindrome-partitioning-ii"}