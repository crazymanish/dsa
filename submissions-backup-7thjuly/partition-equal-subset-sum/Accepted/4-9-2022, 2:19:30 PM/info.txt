{"id":676933764,"lang":"swift","time":"2 months, 4 weeks","timestamp":1649506770,"status_display":"Accepted","runtime":"99 ms","url":"/submissions/detail/676933764/","is_pending":"Not Pending","title":"Partition Equal Subset Sum","memory":"15.7 MB","code":"// Using Top-Down approach\n// https://www.geeksforgeeks.org/0-1-knapsack-problem-dp-10/\nclass Solution {\n    func canPartition(_ nums: [Int]) -> Bool {\n        var sum = 0\n        for num in nums { sum += num }\n\n        if sum % 2 != 0 { return false } // ODD sum (i.e 11) never Partition\n        \n        let expectedSum = sum/2\n        let numsCount = nums.count\n        var dpMatrix: [[Bool]] = Array(repeating: Array(repeating: false, count: (expectedSum + 1)), count: numsCount + 1)\n        \n        for i in 0...numsCount {\n            for j in 0...expectedSum {\n                if i == 0 || j == 0 {\n                    dpMatrix[i][j] = false\n                } else {\n                    let currentNumber = nums[i-1]\n                    \n                    if currentNumber == j {\n                        dpMatrix[i][j] = true        \n                    } else if currentNumber < j {\n                        dpMatrix[i][j] = dpMatrix[i-1][j-currentNumber] || dpMatrix[i-1][j]        \n                    } else {\n                        dpMatrix[i][j] = dpMatrix[i-1][j]  \n                    }\n                }\n            }\n        }\n        \n        return dpMatrix[numsCount][expectedSum]\n    }\n}\n\n/* Using Recursion + DP Memorization-cache\n\nclass Solution {\n    func canPartition(_ nums: [Int]) -> Bool {\n        var sum = 0\n        for num in nums { sum += num }\n\n        if sum % 2 != 0 { return false } // ODD sum (i.e 11) never Partition\n        \n        var dpMemorizationCache: [[Bool?]] = Array(repeating: Array(repeating: nil, count: (sum/2 + 1)), count: nums.count + 1)\n\n        // Let's assume total sum was = 22 then we need to find a subset with equal 11\n        // because rest remaining array elements sum will be left 11 automatically.\n        return canPartition(nums, sum/2, nums.count-1, &dpMemorizationCache)\n    }\n\n    // Knapsack problem variation - Dynamic Programming\n    private func canPartition(_ nums: [Int], _ sum: Int, _ currentIndex: Int, _ cache: inout [[Bool?]]) -> Bool {\n        if sum == 0 { return true }\n        if currentIndex < 0 { return false }\n\n        let currentNumber = nums[currentIndex]\n\n        if currentNumber == sum { return true }\n\n        // Check cache if we already have result or not\n        if let cacheValue = cache[currentIndex][sum] { return cacheValue }\n\n        var result = false\n        \n        if currentNumber < sum {\n            // We have two choices:\n            // Choice1: Consider current-number fit for Partition(subset), keep finding smaller sum in smaller array\n            // Choice2: Ingore current-number fit for Partition, keep finding subset in smaller array\n            result = canPartition(nums, sum-currentNumber, currentIndex-1, &cache) || canPartition(nums, sum, currentIndex-1, &cache)\n        } else {\n            // Only 1 choice:\n            // current-number does not fit for Partition, so keep finding subset in smaller array\n            result = canPartition(nums, sum, currentIndex-1, &cache)\n        }\n\n        // Save result into cache\n        cache[currentIndex][sum] = result\n\n        return result\n    }\n}\n*/","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"partition-equal-subset-sum"}